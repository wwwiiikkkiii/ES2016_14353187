# 死锁（Deadlock）

##### *死锁就是两个或者多个进程，互相请求对方占有的资源。

1. __死锁产生的原因__

   - 系统资源不足
   - 进程运行推进的顺序不合适
   - 资源分配不当

2. __死锁产生的必要条件__

   * 互斥条件：一个资源每次只能被一个进程使用
   * 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
   * 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
   * 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

3. __实验流程__

   * 实验代码

     > Deadlock.java

     ![code](http://p1.bqimg.com/567571/f152eeecf55389f1.png)

     > Deadlock.bat

     ![bat](http://p1.bqimg.com/567571/ad1b4f9b00357e89.png)

   * 程序运行流程

     ![procedure](http://i1.piimg.com/567571/826625795fa8cbea.png)

   * 实验结果

     ![1](http://p1.bqimg.com/567571/8a30c55f07c98b93.png)

   * 结果分析

     如程序运行流程所示，当执行Deadlock类中的主函数时，首先创建类Deadlock，实例化类A和B对象a和b，再调用构造函数，创建线程t，调用t的start函数时，线程t就被插到调度队列里，调度线程t时，执行run函数中的代码。调用对象b方法methodB，methodB又调用对象a的last函数，打印“Inside A.last”信息。这时，有可能主线程的while代码段恰好执行完毕，紧接着要调用对象a方法methodA，methodA又需要调用对象b的last函数。当a和b对象之间形成头尾相接的循环等待资源关系时，死锁便形成了，两个对象都无法调用对方的last函数打印信息。